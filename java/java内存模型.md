# java内存模型

[原文链接](https://blog.csdn.net/suifeng3051/article/details/52611310)

### 线程间通信

1. 共享内存

   通过共享对象进行通信

2. 消息传递

   wait()和notify()

### 线程同步

线程同步是指程序用于控制不同线程之间操作发生的相对顺序的机制.

- 在共享内存并发模型中,同步是显示的,需要程序员显式指定
- 在消息传递并发模型中,同步是隐式的,即先有消息发送,才有消息接收

### java内存模型

java并发采用的是共享内存模型,即是java内存模型(JMM)

**JMM决定一个线程对共享变量的写入何时对另一个线程可见** .

线程与主内存的抽象:

**线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本**。

如下图所示

![](https://img-blog.csdn.net/20160921182337904)

线程A与线程B之间如要通信的话，必须要经历下面2个步骤：

> 1. 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。
> 2. 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。 

![](https://img-blog.csdn.net/20160921182748551)

这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。

**JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证** 。

### JVM对Java内存模型的实现

JMM本身是一个抽象的概念,但是JVM基于这个概念做了实现,即线程栈区和堆区.

![](https://img-blog.csdn.net/20160921182837697)

所有原始类型(boolean,byte,short,char,int,long,float,double)的本地变量都直接保存在线程栈当中，对于它们的值各个线程之间都是独立的。对于原始类型的本地变量，一个线程可以传递一个副本给另一个线程，当它们之间是**无法共享** 的。

堆区包含了Java应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如Byte、Integer、Long等等）。不管对象是属于一个成员变量还是方法中的本地变量，它都会被存储在堆区。

![](https://img-blog.csdn.net/20160921182903818)

一个本地变量如果是原始类型，那么它会被完全存储到栈区。 
一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。

对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。 
对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。

Static类型的变量以及类本身相关信息都会随着类本身存储在堆区。

堆中的对象可以被多线程共享。如果一个线程获得一个对象的应用，它便可访问这个对象的成员变量。如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可同时访问这个对象的成员变量，但是对于本地变量，每个线程都会拷贝一份到自己的线程栈中。